How MLE Encryption Works
MLE uses JWE (JSON Web Encryption) — a standard that combines asymmetric RSA (to share a secret key) with symmetric AES (to encrypt the actual data). Here's exactly how it works step by step:

The Two Algorithms Working Together
RSA-OAEP-256  →  wraps/protects the secret key (asymmetric, slow)
AES-128-GCM   →  encrypts the actual JSON payload (symmetric, fast)

This hybrid approach is standard: RSA is too slow to encrypt large data directly, so AES does the heavy lifting.

Encryption Step-by-Step (Client sending a request)
Code (MLEService.java:82-94 in visa-client):

// Step 1: Build the JWE header
JWEHeader.Builder headerBuilder = new JWEHeader.Builder(
    JWEAlgorithm.RSA_OAEP_256,   // How to protect the key
    EncryptionMethod.A128GCM      // How to encrypt the data
);
headerBuilder.keyID(keyId);                              // "7f591161-..."
headerBuilder.customParam("iat", System.currentTimeMillis()); // timestamp

// Step 2: Wrap plaintext in a Payload
JWEObject jweObject = new JWEObject(headerBuilder.build(), new Payload(plaintext));

// Step 3: Encrypt using the SERVER's public key
jweObject.encrypt(new RSAEncrypter(serverPublicKey));

// Step 4: Serialize to compact form (5 base64url parts)
String jweToken = jweObject.serialize();

Internally, jweObject.encrypt() does:

Generates a random 128-bit CEK (Content Encryption Key — a one-time AES key)
Encrypts the CEK with the server's RSA public key using RSA-OAEP-256
Encrypts the JSON payload with the CEK using AES-128-GCM
AES-GCM also produces an Authentication Tag (tamper detection)
Assembles the JWE compact token
The JWE Token Structure
The output of .serialize() looks like:

eyJhbGciOiJSU0EtT0FFUC0yNTYiLCJlbmMiOiJBMTI4R0NNIiwia2lkIjoiN2Y1OTExNjEtNmI1Zi00MTM2LTgwYjgtMmFlOGE0NGFkOWViIiwiaWF0IjoxNzcxNTE4NjgwMjE0fQ
.
Zs9H3QkPx7...    (Encrypted CEK — RSA-encrypted AES key)
.
aBcDeF12...      (IV — random Initialization Vector for AES-GCM)
.
xYz9K3mP...      (Ciphertext — your encrypted JSON)
.
tAgV4lMn...      (Authentication Tag — integrity check)

5 parts, separated by dots:

Part	What it contains
Header	Algorithm info: alg, enc, kid, iat (Base64URL-encoded JSON)
Encrypted Key	The CEK encrypted with RSA-OAEP-256 (only recipient's private key can recover it)
IV	Random 96-bit nonce for AES-GCM (never reused)
Ciphertext	The actual JSON payload encrypted with AES-128-GCM
Auth Tag	128-bit GMAC tag — verifies nothing was tampered
Decryption Step-by-Step (Server decrypting a request)
Code (MLEService.java:79-86 in visa-server):

// Step 1: Parse the 5-part JWE token
JWEObject jweObject = JWEObject.parse(jweToken);

// Step 2: Decrypt using SERVER's private key
jweObject.decrypt(new RSADecrypter(serverPrivateKey));

// Step 3: Get plaintext
String decrypted = jweObject.getPayload().toString();

Internally, jweObject.decrypt() does:

Uses the server's RSA private key to decrypt the Encrypted Key part → recovers the CEK
Uses the CEK + IV to AES-GCM decrypt the ciphertext
Verifies the Authentication Tag — if tampered, throws an exception
Returns plaintext JSON
Key Loading: How PEM Files are Parsed
Public Key (from X.509 certificate, loadRSAPublicKey at line 118):

// Strip PEM headers, Base64 decode, parse as X.509 certificate
String base64Content = pemContent
    .replace("-----BEGIN CERTIFICATE-----", "")
    .replace("-----END CERTIFICATE-----", "")
    .replaceAll("\\s", "");
byte[] decoded = Base64.getDecoder().decode(base64Content);
Certificate cert = CertificateFactory.getInstance("X.509")
    .generateCertificate(new ByteArrayInputStream(decoded));
return (RSAPublicKey) cert.getPublicKey();

Private Key (two formats supported, loadRSAPrivateKey at line 136):

PKCS#1  (-----BEGIN RSA PRIVATE KEY-----)  ← Visa standard
   → Parsed manually via BouncyCastle ASN1
   → Extracts: modulus + privateExponent from DER sequence
   → Builds RSAPrivateKeySpec

PKCS#8  (-----BEGIN PRIVATE KEY-----)  ← Java standard
   → Simpler: pass raw bytes to PKCS8EncodedKeySpec

The Full Encryption Flow (Both directions)
REQUEST (Client → Server)
─────────────────────────
Plain JSON
  ↓  encrypt with mle-server-public.pem  (only server can decrypt)
JWE Token
  ↓  wrapped in {"encData": "<JWE>"}
  ↓  sent over mTLS
  ↓  server decrypts with mle-server-private.pem
Plain JSON  ✓

RESPONSE (Server → Client)
──────────────────────────
Plain JSON
  ↓  encrypt with mle-client-public.pem  (only client can decrypt)
JWE Token
  ↓  wrapped in {"encData": "<JWE>"}
  ↓  sent over mTLS
  ↓  client decrypts with mle-client-private.pem
Plain JSON  ✓

Why AES-GCM specifically?
AES-128-GCM provides Authenticated Encryption:

Confidentiality: Nobody can read the data without the CEK
Integrity: The auth tag detects any bit-level tampering
Authenticity: Confirms the data came from someone who had the key
If anyone modifies even one byte of the ciphertext, decryption throws a JOSEException — the transaction is rejected.
