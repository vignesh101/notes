rst, Understand the Core Idea â€” The Locked Box Analogy
Imagine you want to send a secret letter to your friend:

YOU have:
  ğŸ”‘ Your friend's PUBLIC key  â†’  like a PADLOCK your friend gave you (open)
  ğŸ”‘ Your own PRIVATE key      â†’  like your own secret key (only you have it)

YOUR FRIEND has:
  ğŸ”‘ Their own PRIVATE key     â†’  only they can OPEN their padlock
  ğŸ”‘ Your PUBLIC key           â†’  to send secrets back to YOU

Sending a secret:

You  â†’  lock box with friend's padlock  â†’  only friend can open it  â†’  Friend

Friend replies:

Friend  â†’  lock box with YOUR padlock  â†’  only you can open it  â†’  You

ğŸ”‘ Two Types of Keys
Key Type	Who Has It	What It Does
Public Key	Everyone (shared openly)	Used to ENCRYPT (lock the box)
Private Key	Only the owner (secret)	Used to DECRYPT (open the box)
Rule: What PUBLIC key locks â†’ only the matching PRIVATE key can unlock

ğŸ—ï¸ MLE Uses TWO Algorithms (Hybrid Encryption)
Why two algorithms?
RSA alone  â†’  Very SLOW for large data (like encrypting a whole JSON)
AES alone  â†’  Fast, but how do you securely share the AES key?

SOLUTION: Use BOTH!
  RSA  â†’  securely share a secret key (small data, slow is OK)
  AES  â†’  encrypt the actual JSON data (large data, needs to be fast)

ğŸ“¦ Step-by-Step: What Happens Inside encrypt()
The Client wants to send this JSON to the server:
{
  "amount": "124.05",
  "recipientPrimaryAccountNumber": "4957030420210496",
  "senderName": "Mohammed Qasim"
}

Step 1 â€” Generate a Random Secret Key (CEK)
ğŸ² Generate a random 128-bit key called CEK
   (Content Encryption Key â€” a one-time-use AES key)

   CEK = [random bytes: a3 f9 2b 11 ... 16 bytes total]

   This key is THROWN AWAY after one use â€” brand new every time!

Step 2 â€” Encrypt the JSON with CEK (AES-128-GCM)
Plain JSON  +  CEK  +  Random IV
     â†“
  AES-128-GCM encryption
     â†“
  Ciphertext (scrambled unreadable bytes)  +  Auth Tag

  Example:
  "amount":"124.05"  â†’  xK9#mP@!2q...  (meaningless bytes)

What is IV?

IV = Initialization Vector = random number used ONCE
     Like a salt â€” ensures same JSON encrypted twice gives DIFFERENT ciphertext
     Prevents pattern attacks

What is Auth Tag?

Auth Tag = a fingerprint of the encrypted data
           If anyone changes even ONE BYTE of ciphertext,
           the Auth Tag check FAILS â†’ decryption rejected!
           Detects tampering.

Step 3 â€” Encrypt the CEK with RSA (RSA-OAEP-256)
CEK (the secret AES key)  +  Server's PUBLIC key
          â†“
    RSA-OAEP-256 encryption
          â†“
    Encrypted CEK (only server's PRIVATE key can recover this!)

Now even if someone intercepts the message, they can't get the CEK â€” only the server's private key can unlock it.

Step 4 â€” Assemble the JWE Token (5 Parts)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Part 1      Part 2          Part 3    Part 4        Part 5     â”‚
â”‚  â”€â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€        â”€â”€â”€â”€â”€â”€     â”‚
â”‚  Header   . Encrypted CEK . IV      . Ciphertext . Auth Tag    â”‚
â”‚                                                                  â”‚
â”‚  eyJhbGci  .  Zs9H3QkP   . aBcDeF  .  xYz9K3mP  .  tAgV4lMn  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†‘              â†‘            â†‘           â†‘            â†‘
  Algorithm      RSA-locked    Random      Encrypted    Tamper
  info, keyId    AES key       nonce       JSON         detector

The Header (Part 1) decoded looks like:

{
  "alg": "RSA-OAEP-256",
  "enc": "A128GCM",
  "kid": "7f591161-6b5f-4136-80b8-2ae8a44ad9eb",
  "iat": 1771518680214
}

Final Output â€” Wrapped in JSON:
{
  "encData": "eyJhbGci...Zs9H3QkP...aBcDeF...xYz9K3mP...tAgV4lMn"
}

ğŸ”“ Step-by-Step: What Happens Inside decrypt()
The server receives {"encData": "<JWE token>"} and needs to read the JSON.

Step 1 â€” Parse the JWE Token (Split by dots)
eyJhbGci...  .  Zs9H3QkP...  .  aBcDeF...  .  xYz9K3mP...  .  tAgV4lMn...
     â†“               â†“              â†“               â†“                â†“
  Header       Encrypted CEK       IV          Ciphertext        Auth Tag

Step 2 â€” Decrypt the CEK using Server's PRIVATE Key
Encrypted CEK  +  Server's PRIVATE key
        â†“
   RSA-OAEP-256 decryption
        â†“
   CEK recovered!  [a3 f9 2b 11 ...]

Step 3 â€” Verify the Auth Tag
AES-GCM checks: does the Auth Tag match the ciphertext?
   âœ… Matches   â†’ data is safe, proceed
   âŒ No match  â†’ data was TAMPERED, throw exception, reject!

Step 4 â€” Decrypt the Ciphertext using CEK + IV
Ciphertext  +  CEK  +  IV
      â†“
  AES-128-GCM decryption
      â†“
  Plain JSON! âœ…

{
  "amount": "124.05",
  "recipientPrimaryAccountNumber": "4957030420210496",
  "senderName": "Mohammed Qasim"
}

ğŸ—ºï¸ Complete Visual Flow (Client â†’ Server â†’ Client)
CLIENT                                          SERVER
  â”‚                                               â”‚
  â”‚  Plain JSON                                   â”‚
  â”‚      â†“                                        â”‚
  â”‚  ğŸ² Generate random CEK                       â”‚
  â”‚      â†“                                        â”‚
  â”‚  ğŸ”’ AES-GCM encrypt JSON with CEK             â”‚
  â”‚      â†’ Ciphertext + Auth Tag                  â”‚
  â”‚      â†“                                        â”‚
  â”‚  ğŸ”’ RSA encrypt CEK with SERVER public key    â”‚
  â”‚      â†’ Encrypted CEK                          â”‚
  â”‚      â†“                                        â”‚
  â”‚  ğŸ“¦ Assemble JWE token (5 parts)              â”‚
  â”‚      â†“                                        â”‚
  â”‚  {"encData": "eyJ..."}  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º   â”‚
  â”‚                                               â”‚  ğŸ“¦ Parse JWE (split by '.')
  â”‚                                               â”‚  ğŸ”“ RSA decrypt Encrypted CEK
  â”‚                                               â”‚      using SERVER private key
  â”‚                                               â”‚      â†’ recover CEK
  â”‚                                               â”‚  âœ… Verify Auth Tag
  â”‚                                               â”‚  ğŸ”“ AES-GCM decrypt Ciphertext
  â”‚                                               â”‚      using CEK + IV
  â”‚                                               â”‚      â†’ Plain JSON âœ…
  â”‚                                               â”‚
  â”‚                                               â”‚  ğŸ“ Process transaction...
  â”‚                                               â”‚
  â”‚                                               â”‚  ğŸ² Generate NEW random CEK
  â”‚                                               â”‚  ğŸ”’ AES-GCM encrypt response
  â”‚                                               â”‚  ğŸ”’ RSA encrypt CEK
  â”‚                                               â”‚      with CLIENT public key
  â”‚                                               â”‚  ğŸ“¦ Assemble JWE
  â”‚   â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  {"encData": "eyJ..."}  â”‚
  â”‚                                               â”‚
  â”‚  ğŸ“¦ Parse JWE                                 â”‚
  â”‚  ğŸ”“ RSA decrypt with CLIENT private key       â”‚
  â”‚  âœ… Verify Auth Tag                           â”‚
  â”‚  ğŸ”“ AES-GCM decrypt â†’ Plain JSON âœ…          â”‚

ğŸ”‘ Which Key Is Used Where?
                      ENCRYPT WITH          DECRYPT WITH
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Client â†’ Server     â”‚ Server PUBLIC key â”‚ Server PRIVATE key   â”‚
(request)           â”‚ (mle-server-     â”‚ (mle-server-         â”‚
                    â”‚  public.pem)     â”‚  private.pem)        â”‚
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
Server â†’ Client     â”‚ Client PUBLIC keyâ”‚ Client PRIVATE key   â”‚
(response)          â”‚ (mle-client-     â”‚ (mle-client-         â”‚
                    â”‚  public.pem)     â”‚  private.pem)        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ§© Why Each Piece Exists (Summary)
Piece	Algorithm	Why It's Needed
RSA-OAEP-256	Asymmetric (public/private key)	Safely shares the secret AES key
AES-128-GCM	Symmetric (same key both sides)	Fast encryption of actual JSON data
CEK	Random 128-bit key	One-time AES key, different for every message
IV / Nonce	Random 96-bit value	Same JSON encrypted twice â†’ different output
Auth Tag	GMAC 128-bit fingerprint	Detects if ciphertext was tampered
kid (Key ID)	"7f591161-..."	Tells server which key to use for decryption
iat	Timestamp	Helps detect replay attacks (reusing old tokens)
ğŸ¯ One-Line Summary
MLE = RSA locks the AES key â†’ AES locks the data â†’ both travel together as a JWE token â†’ only the right private key can unlock everything


How MLE Encryption Works
MLE uses JWE (JSON Web Encryption) â€” a standard that combines asymmetric RSA (to share a secret key) with symmetric AES (to encrypt the actual data). Here's exactly how it works step by step:

The Two Algorithms Working Together
RSA-OAEP-256  â†’  wraps/protects the secret key (asymmetric, slow)
AES-128-GCM   â†’  encrypts the actual JSON payload (symmetric, fast)

This hybrid approach is standard: RSA is too slow to encrypt large data directly, so AES does the heavy lifting.

Encryption Step-by-Step (Client sending a request)
Code (MLEService.java:82-94 in visa-client):

// Step 1: Build the JWE header
JWEHeader.Builder headerBuilder = new JWEHeader.Builder(
    JWEAlgorithm.RSA_OAEP_256,   // How to protect the key
    EncryptionMethod.A128GCM      // How to encrypt the data
);
headerBuilder.keyID(keyId);                              // "7f591161-..."
headerBuilder.customParam("iat", System.currentTimeMillis()); // timestamp

// Step 2: Wrap plaintext in a Payload
JWEObject jweObject = new JWEObject(headerBuilder.build(), new Payload(plaintext));

// Step 3: Encrypt using the SERVER's public key
jweObject.encrypt(new RSAEncrypter(serverPublicKey));

// Step 4: Serialize to compact form (5 base64url parts)
String jweToken = jweObject.serialize();

Internally, jweObject.encrypt() does:

Generates a random 128-bit CEK (Content Encryption Key â€” a one-time AES key)
Encrypts the CEK with the server's RSA public key using RSA-OAEP-256
Encrypts the JSON payload with the CEK using AES-128-GCM
AES-GCM also produces an Authentication Tag (tamper detection)
Assembles the JWE compact token
The JWE Token Structure
The output of .serialize() looks like:

eyJhbGciOiJSU0EtT0FFUC0yNTYiLCJlbmMiOiJBMTI4R0NNIiwia2lkIjoiN2Y1OTExNjEtNmI1Zi00MTM2LTgwYjgtMmFlOGE0NGFkOWViIiwiaWF0IjoxNzcxNTE4NjgwMjE0fQ
.
Zs9H3QkPx7...    (Encrypted CEK â€” RSA-encrypted AES key)
.
aBcDeF12...      (IV â€” random Initialization Vector for AES-GCM)
.
xYz9K3mP...      (Ciphertext â€” your encrypted JSON)
.
tAgV4lMn...      (Authentication Tag â€” integrity check)

5 parts, separated by dots:

Part	What it contains
Header	Algorithm info: alg, enc, kid, iat (Base64URL-encoded JSON)
Encrypted Key	The CEK encrypted with RSA-OAEP-256 (only recipient's private key can recover it)
IV	Random 96-bit nonce for AES-GCM (never reused)
Ciphertext	The actual JSON payload encrypted with AES-128-GCM
Auth Tag	128-bit GMAC tag â€” verifies nothing was tampered
Decryption Step-by-Step (Server decrypting a request)
Code (MLEService.java:79-86 in visa-server):

// Step 1: Parse the 5-part JWE token
JWEObject jweObject = JWEObject.parse(jweToken);

// Step 2: Decrypt using SERVER's private key
jweObject.decrypt(new RSADecrypter(serverPrivateKey));

// Step 3: Get plaintext
String decrypted = jweObject.getPayload().toString();

Internally, jweObject.decrypt() does:

Uses the server's RSA private key to decrypt the Encrypted Key part â†’ recovers the CEK
Uses the CEK + IV to AES-GCM decrypt the ciphertext
Verifies the Authentication Tag â€” if tampered, throws an exception
Returns plaintext JSON
Key Loading: How PEM Files are Parsed
Public Key (from X.509 certificate, loadRSAPublicKey at line 118):

// Strip PEM headers, Base64 decode, parse as X.509 certificate
String base64Content = pemContent
    .replace("-----BEGIN CERTIFICATE-----", "")
    .replace("-----END CERTIFICATE-----", "")
    .replaceAll("\\s", "");
byte[] decoded = Base64.getDecoder().decode(base64Content);
Certificate cert = CertificateFactory.getInstance("X.509")
    .generateCertificate(new ByteArrayInputStream(decoded));
return (RSAPublicKey) cert.getPublicKey();

Private Key (two formats supported, loadRSAPrivateKey at line 136):

PKCS#1  (-----BEGIN RSA PRIVATE KEY-----)  â† Visa standard
   â†’ Parsed manually via BouncyCastle ASN1
   â†’ Extracts: modulus + privateExponent from DER sequence
   â†’ Builds RSAPrivateKeySpec

PKCS#8  (-----BEGIN PRIVATE KEY-----)  â† Java standard
   â†’ Simpler: pass raw bytes to PKCS8EncodedKeySpec

The Full Encryption Flow (Both directions)
REQUEST (Client â†’ Server)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Plain JSON
  â†“  encrypt with mle-server-public.pem  (only server can decrypt)
JWE Token
  â†“  wrapped in {"encData": "<JWE>"}
  â†“  sent over mTLS
  â†“  server decrypts with mle-server-private.pem
Plain JSON  âœ“

RESPONSE (Server â†’ Client)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Plain JSON
  â†“  encrypt with mle-client-public.pem  (only client can decrypt)
JWE Token
  â†“  wrapped in {"encData": "<JWE>"}
  â†“  sent over mTLS
  â†“  client decrypts with mle-client-private.pem
Plain JSON  âœ“

Why AES-GCM specifically?
AES-128-GCM provides Authenticated Encryption:

Confidentiality: Nobody can read the data without the CEK
Integrity: The auth tag detects any bit-level tampering
Authenticity: Confirms the data came from someone who had the key
If anyone modifies even one byte of the ciphertext, decryption throws a JOSEException â€” the transaction is rejected.
